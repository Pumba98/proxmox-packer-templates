locals {
  unattended_content = {
    for key, value in var.unattended_content : key => templatefile(value.template, merge(value.vars, {
      winrm_username = var.winrm_username
      winrm_password = var.winrm_password
      windows_edition = var.windows_edition == "" ? value.vars.image_name : var.windows_edition
      windows_language = var.windows_language
      windows_input_language = var.windows_input_language
    }))
  }
  unattended_as_cd = length(var.unattended_content) > 0 ? [{
    type = "sata"
    index = 3 + length(var.unattended_content)
    content = local.unattended_content
    label   = "Windows Unattended CD"
  }] : []
  additional_cd_files = concat(var.additional_cd_files, local.unattended_as_cd)
}

source "proxmox-iso" "vm" {
  proxmox_url              = "https://${var.proxmox_host}/api2/json"
  username                 = var.proxmox_user
  password                 = var.proxmox_password
  token                    = var.proxmox_token
  insecure_skip_tls_verify = var.proxmox_insecure_tls

  vm_id                = var.vmid
  vm_name              = var.name
  template_name        = var.name
  template_description = var.description == "" ? "${var.name}, generated by packer at ${formatdate("YYYY-MM-DD hh:mm:ss", timestamp())}" : var.description
  node                 = var.node
  pool                 = var.pool

  cpu_type = var.cpu_type
  sockets  = var.cpu_sockets
  cores    = var.cpu_cores
  memory   = var.memory

  http_interface    = var.packer_http_interface
  http_bind_address = var.packer_http_bind_address
  http_port_min     = var.packer_http_port == -1 ? 8000 : "${var.packer_http_port}"
  http_port_max     = var.packer_http_port == -1 ? 9000 : "${var.packer_http_port}"

  disks {
    storage_pool      = var.disk_storage_pool
    disk_size         = var.disk_size
    format            = var.disk_format
    type              = var.disk_type
    cache_mode        = var.disk_cache
  }

  network_adapters {
    bridge      = var.network_adapter
    model       = var.network_adapter_model
    mac_address = var.network_adapter_mac
    vlan_tag    = var.network_adapter_vlan == -1 ? "" : "${var.network_adapter_vlan}"
    firewall    = var.network_adapter_firewall
  }

  vga {
    type   = var.vga_type
    memory = var.vga_memory
  }

  os              = var.os
  scsi_controller = var.scsi_controller
  onboot          = var.start_at_boot
  qemu_agent      = var.qemu_agent
  bios            = var.bios

  boot_iso {
    # type             = var.iso_type
    # index            = var.iso_index
    iso_file         = var.iso_download ? "" : "${var.iso_storage_pool}:iso/${var.iso_file}"
    iso_storage_pool = var.iso_storage_pool
    iso_url          = var.iso_download ? var.iso_url : ""
    iso_checksum     = var.iso_checksum
    iso_download_pve = var.iso_download_pve
    unmount          = var.iso_unmount
  }

  dynamic "additional_iso_files" {
    for_each = var.additional_iso_files
    content {
      # type             = additional_iso_files.value.type
      # index            = additional_iso_files.value.index
      iso_file         = var.iso_download ? "" : "${var.iso_storage_pool}:iso/${additional_iso_files.value.iso_file}"
      iso_storage_pool = var.iso_storage_pool
      iso_url          = var.iso_download ? additional_iso_files.value.iso_url : ""
      iso_checksum     = additional_iso_files.value.iso_checksum
      iso_download_pve = var.iso_download_pve
      unmount          = var.iso_unmount
    }
  }

  dynamic "additional_iso_files" {
    for_each = local.additional_cd_files
    iterator = iso
    content {
      type             = iso.value.type
      index            = iso.value.index
      iso_storage_pool = var.iso_storage_pool
      cd_files         = contains(keys(iso.value), "files") ? iso.value.files : []
      cd_content       = contains(keys(iso.value), "content") ? iso.value.content : {}
      cd_label         = contains(keys(iso.value), "label") ? iso.value.label : ""
      unmount          = var.iso_unmount
    }
  }

  cloud_init              = var.cloud_init
  cloud_init_storage_pool = var.cloud_init_storage_pool

  boot           = "order=${var.disk_type}0;ide2;net0"
  boot_command   = var.boot_command
  boot_wait      = var.boot_wait
  task_timeout   = var.task_timeout
  http_directory = var.http_directory
  communicator   = var.communicator
  ssh_username   = var.ssh_username
  ssh_password   = var.ssh_password
  ssh_timeout    = var.ssh_timeout
  winrm_username = var.winrm_username
  winrm_password = var.winrm_password
  winrm_insecure = var.winrm_insecure
  winrm_use_ssl  = var.winrm_use_ssl
}

build {
  name    = "linux"
  sources = ["source.proxmox-iso.vm"]

  provisioner "shell" {
    execute_command = "echo 'packer' | {{ .Vars }} sudo -S -E sh -eux '{{ .Path }}'"
    inline          = var.provisioner
    skip_clean      = true
  }
}

build {
  name    = "opnsense"
  sources = ["source.proxmox-iso.vm"]
}

build {
  name    = "windows"
  sources = ["source.proxmox-iso.vm"]
}
